mod bflru {
    // This table was generated by compiling and running tablegen.c
    // Usage: new_state = STATE_TRANSITIONS[old_state][index]
    // where index = 0 => MRU, index = 3 => LRU.
    static STATE_TRANSITIONS: &'static [[u8; 4]; 24] = &[
        [0x00, 0x01, 0x02, 0x03],
        [0x01, 0x00, 0x06, 0x07],
        [0x02, 0x04, 0x05, 0x0b],
        [0x03, 0x08, 0x09, 0x0a],
        [0x04, 0x02, 0x01, 0x0f],
        [0x05, 0x06, 0x00, 0x13],
        [0x06, 0x05, 0x04, 0x17],
        [0x07, 0x09, 0x08, 0x16],
        [0x08, 0x03, 0x0d, 0x0e],
        [0x09, 0x07, 0x0c, 0x12],
        [0x0a, 0x0b, 0x10, 0x11],
        [0x0b, 0x0a, 0x14, 0x15],
        [0x0c, 0x0d, 0x03, 0x02],
        [0x0d, 0x0c, 0x07, 0x06],
        [0x0e, 0x10, 0x0b, 0x05],
        [0x0f, 0x14, 0x0a, 0x09],
        [0x10, 0x0e, 0x0f, 0x01],
        [0x11, 0x12, 0x13, 0x00],
        [0x12, 0x11, 0x17, 0x04],
        [0x13, 0x15, 0x16, 0x08],
        [0x14, 0x0f, 0x0e, 0x0d],
        [0x15, 0x13, 0x12, 0x0c],
        [0x16, 0x17, 0x11, 0x10],
        [0x17, 0x16, 0x15, 0x14],
    ];

    pub struct Cache<T> {
        contents: [T; 4],
        order: u8,
    }

    impl<T> Cache<T> {
        // Gets an element from the cache as specified by the `index` parameter,
        // where 0 is the most recently used element, and 3 is the least recently used.
        pub fn get(&mut self, index: usize) -> &T {
            self.order = STATE_TRANSITIONS[self.order as usize][index];
            &self.contents[(self.order & 3) as usize]
        }

        // Evicts the least recently used element from the cache and inserts
        // the specified value, making it the most recently used element.
        pub fn put(&mut self, value: T) {
            self.order = STATE_TRANSITIONS[self.order as usize][3];
            self.contents[(self.order & 3) as usize] = value;
        }
    }

    impl<T: Default> Cache<T> {
        // Initializes a cache with all elements set to the cached type's default value.
        pub fn new() -> Cache<T> {
            Cache {
                order: 0,
                contents: [
                    T::default(),
                    T::default(),
                    T::default(),
                    T::default()
                ],
            }
        }
    }

    impl<T: PartialEq> Cache<T> {
        // Searches the cache for the specified value, returning the old index
        // before making it the most recently used, (i.e. setting its index to
        // zero). This immediately invalidates the returned index (unless it
        // already _was_ the most recently element), but this is actually what
        // you want in most LZ-style encoders.
        // Returns None if the cache does not contain the specified value.
        pub fn find(&mut self, value: &T) -> Option<usize> {
            for i in 0..4 {
                let new_order = STATE_TRANSITIONS[self.order as usize][i];
                
                if self.contents[(new_order & 3) as usize].eq(value) {
                    self.order = new_order;
                    return Some(i);
                }
            }
            
            None
        }
    }
    
    #[cfg(test)]
    mod tests {
        use bflru::Cache;

        // This is a fairly ad-hoc test of the basic functionality.
        // 
        // If there is an elegant way to exhaustively check all 24 states
        // against all valid operations, without writing out the full sequence
        // of function calls, and without essentially reimplementing the state
        // machine in the test case, this code would be easy to prove correct.
        #[test]
        fn basic_usage() {
            let mut test_cache = Cache::<u8>::new();

            test_cache.put(1);
            test_cache.put(2);
            test_cache.put(3);
            test_cache.put(4);

            assert!(test_cache.find(&5).is_none());
            
            assert_eq!(*test_cache.get(0), 4);

            assert_eq!(*test_cache.get(3), 1);
            assert_eq!(*test_cache.get(0), 1);

            assert_eq!(*test_cache.get(3), 2);
            assert_eq!(*test_cache.get(0), 2);

            assert_eq!(*test_cache.get(3), 3);
            assert_eq!(*test_cache.get(0), 3);

            assert_eq!(*test_cache.get(3), 4);
            assert_eq!(*test_cache.get(0), 4);
            
            assert_eq!(test_cache.find(&3).unwrap(), 1);
            assert_eq!(*test_cache.get(0), 3);
        }
    }
}
